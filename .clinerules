# AI Coding with TypeScript: ベストプラクティス

これは TypeScript と AI を駆使してコードを書く際の使い方についてまとめた資料。人間が読む以外に、コーディングエージェントがプロンプトとして読むことを想定する。

## コーディングポリシー

- 最初に型と、それを処理する関数のインターフェースを考える
- コードのコメントとして、そのファイルがどういう仕様化を可能な限り明記する
- 実装が内部状態を持たないとき、 class による実装を避けて関数を優先する
- 副作用を抽象するために、アダプタパターンで外部依存を抽象し、テストではインメモリなアダプタで処理する
- パッケージ管理ツールはpnpmを使用する
- 余計なライブラリは依存関係が増えるため入れない
- ステップバイステップで実装を進めテストコードを都度追加する
- テストにはvitestを使用する

### 型定義の方針

- 可能な限り具体的な型を使用し、any の使用を避ける
- 共通の型パターンには Utility Types を活用する
- 型エイリアスは意味のある名前をつけ、型の意図を明確にする

```ts
// 良い例
type UserId = string;
type UserData = {
  id: UserId;
  createdAt: Date;
};

// 避けるべき例
type Data = any;
```

## テストの書き方

`vitest` を使う。
とくに実装上の理由がない限り、 `describe` による入れ子はしない。

## 実装モード: スクリプトモード

- 外部依存を可能な限り減らして、一つのファイルに完結してすべてを記述する
- テストコードも同じファイルに記述してください

CLINE/Rooのようなコーディングエージェントは、まず `node add.ts` で実行して、要求に応じて `deno test -A <filename>` で実行可能なようにテストを増やしていく。

## コード品質の監視

カバレッジの目標値：
- 新規実装時は80%以上のカバレッジを目標とする
- 重要なビジネスロジックは90%以上を目指す

実行コードと純粋な関数を分離することで、高いカバレッジを維持します：

### デッドコード解析

- TSR (TypeScript Runtime) を使用してデッドコードを検出
- 未使用のエクスポートや関数を定期的に確認し削除